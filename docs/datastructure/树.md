
> 树型结构（包括树和二叉树）是一种非常重要的 `非线性` 结构。它所描述的数据具有明显的 `层次` 关系，其中的每个元素最多只有一个前驱（父辈），但可能有多个后继（后代）。由于树型结构中的各子结构与整个结构具有相似的特性，因而其算法大多采用递归形式。

## 树的基本概念
树的定义有两点：
1. 有且仅有一个特定的称为根（root）的结点；
2. 当结点数量>1时，其余结点可分为若干个互不相交的有限集，其中每个集合也可以看作一颗树，称之为根的子树。

## 基本术语
- 结点的度：结点的分支数。
- 树的度：树中所有结点度的最大值。
- 结点的层次：书中根结点的层次为1，根结点子树的跟为第2层，以此类推。
- 树的深度：树中所有结点度层次的最大值。
- 树的高度：树的深度 -1。

## 二叉树
> 二叉树(binary)是一种特殊的树，主要有以下两个特征：
> 1. 每个结点 `最多` 有 `两棵` 子树。
> 2. 子树有左右之分。

### 完全二叉树
> 若设二叉树的深度为h，除第 h 层外，`其它各层` (1～h-1) 的结点数都达到 `最大个数`，第 h 层所有的结点都连续集中在 `最左边`。


### 满二叉树
> `每层` 的结点数都达到 `最大值`。

## 二叉树遍历
- 先序遍历：中、左、右
- 中序遍历：左、中、右
- 后序遍历：左、右、中 

拿中序遍历举个栗子，其他同理：
<br>
<img src="https://i.loli.net/2020/06/01/ZcoLF3vdThOVw61.png" width="600" height="300">
<img src="https://i.loli.net/2020/06/01/rv87DkMaW3RxCdA.png" width="700" height="250">
<img src="https://i.loli.net/2020/06/01/fkTKnpcoMJbVB6s.png" width="700" height="250">

最终结果：
- 4 2 5 1 6 3 7

### 二叉树遍历代码实现
- [博客教程](https://blog.csdn.net/u011514810/article/details/75907170)
- [视频教程](https://www.bilibili.com/video/BV1Qx411m7Lb?from=search&seid=12848577558912608443)

###  二叉树的存储结构
> 二叉树通常采用两种存储方式：顺序存储结构和链式存储结构。

#### 顺序存储结构
这种存储结构适用于完全二叉树。其存储形式为：用一组连续的存储单元按照**完全二叉树**的每个结点编号的顺序存放结点内容。

这种存储结构特点是空间利用率高，寻找孩子和双亲比较容易，然而这种方法也存在问题：若二叉树不是完全二叉树，则为了体现
出孩子、双亲关系，需要将空缺的位置用特定的符号填充，若空缺结点较多，势必造成空间利用率的下降。为此，
要求存储结构能依据实际节点数分配存储空间，这就涉及了动态链表结构。

#### 链式存储结构
链式存储结构是二叉树 `最常用` 的存储结构。其中，Lchild和Rchild是分别指向该结点左孩子和右孩子的指针，data是数据元素的内容。
和单链表类似，一个二叉链表由头指针唯一确定，若二叉树为空，则头指针指向空（NULL），若结点的某个孩子不存在，
则相应的指针为空，在一个具有N个结点的二叉树中，共有2N个指针域，其中只有N-1个用来指示结点的左孩子和右孩子，
其他N+1个指针域为空。

这种存储结构的特点是寻找孩子结点容易，寻找双亲比较困难。因此，若需要频繁地寻找双亲，可以给每个结点添加一个指向双亲结点的指针域

## 二叉搜索树（Binary Search Tree）
二叉搜索树是一种特殊的二叉树，也可以称为二叉查找树，它改善了二叉树结点查找的效率。除了具有二叉树的基本性质外，它还具备：
1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。
2. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。

这样，搜索的时候，比根结点小的走左边，否则走右边。

## 平衡二叉查找树
> 父亲节点的 左子树和右子树的高度之差不能大于1 的二叉搜索树。简称平衡二叉树。也称为 AVL 树。

### 为什么需要平衡二叉树
二叉搜索树虽然在插入和删除时效率都有所提升，但是如果二叉树变成了下图：

<img src="https://i.loli.net/2020/06/02/tNcDbPEHKxkrLG2.png" >

二叉树快退化成链表了，搜索效率就会变得很低，时间复杂度有logn退化到n，这时候我们需要添加一些额外的条件来约束它，使其可以保持具有logn的时间复杂度。

### AVL树插入时的失衡与调整

### 平衡因子
`某节点` 的左子树与右子树的高度差即为该节点的平衡因子，平衡二叉树中不存在平衡因子大于1的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。

### 最小失衡树
在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小不平衡树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。

**平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的**。根据旋转的方向有两种处理方式，`左旋` 与 `右旋` 。

旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。

### 左旋
1. 节点的右孩子替代此节点位置。
2. 右孩子的左子树变为该节点的右子树。
3. 节点本身变为右孩子的左子树。

### 右旋
1. 节点的左孩子代表此节点。 
2. 节点的左孩子的右子树变为节点的左子树。
3. 将此节点作为左孩子节点的右子树。


### AVL树与红黑树
- `AVL树`：最先发明的自平衡二叉查找树。每当插入一个结点，看是不是因为树的插入破坏了树的平衡性，
若是，则找出最小不平衡树。在保持二叉树特性的前提下，调整最小不平衡子树中各个结点之间的链接关系，
进行相应的旋转，使之成为新的平衡子树。简记为： `步步调整，步步平衡` 。
- `红黑树`：红黑树并不追求 `完全平衡`——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。
在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个
节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树
（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），
相对于要求严格的AVL树来说，它的旋转次数少。

### 红黑树特性
红黑树在原有的二叉查找树基础上增加了如下几个要求：
1. 每个节点要么是红色，要么是黑色；
2. 根节点永远是黑色的；
3. 所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；
4. 每个红色节点的两个子节点一定都是黑色；
5. 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；

### 我最开始是这样想的
- 幼稚的想法：
    - 二叉树做了这么多就是为了查询速度接近与二分法查找，那么我们为啥不直接用数组或者是链表去存，不就可以更加直接的
使用二分法查找吗？
- 现实的世界：
    - 数组？？数组可以使用二分法查找，但是数组需要占用连续的物理内存空间，往中间插入，需要移动后面所有的元素，你觉得能行吗？
    - 链表？？插入是没问题了，那怎么找到中间的元素？？好的，从头开始遍历。连二分法查找都用不上。
    
 还是要二叉树吧？当然想数据库索引，二叉树还满足不了。得用B树、B+树，下面一起看吧。

### B树
> B树是m叉的多路平衡查找树。

定义：
- 每个节点最多有 m-1 个关键字。
- 根节点最少可以只有1个关键字。
- 非根节点至少有m/2个关键字。
- 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，
而右子树中的所有关键字都大于它。
- 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。
- 每个节点都存有索引和数据，也就是对应的 key 和 value。

B树插入：判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。

### B+树
B+树 与 B树 非常相似，下面看看不同点。
- B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
- 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。所有的叶子节点形成了一个有序链表，更加便于查找。
- 父节点存有右孩子的第一个元素的索引。

B+树插入：当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点 `当做索引存储`，但是，本身中间元素还是分裂右边这一部分的。

## 数据库索引【数据结构】探究
> 下面来探讨一下什么数据结构最适合数据库索引。

### 局部性原理与磁盘预读

> 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，
要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格 `按需读取`，而是每次都会 `预读`，即使只需要一个字节，磁盘也会从这个
位置开始，顺序向后读取一定长度的数据 `放入内存`。

这样做的理论依据是计算机科学中著名的局部性原理： 
- 当一个数据被用到时，其附近的数据也通常会马上被使用。 
- 程序运行期间所需要的数据通常比较集中。 
- 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。


### 为什么平衡二叉树不适合作为索引
平衡二叉树结构，指的是逻辑结构上的平衡二叉树，其物理实现是 `链表`。然后由于在 `逻辑结构` 上相近的节点在 `物理结构` 上可能会 `差很远`。
因此，每次读取的磁盘页的数据中有许多是 `用不上` 的。因此，查找过程中要进行许多次的 `磁盘读取` 操作。【红黑树没能充分利用磁盘预读功能】

而适合作为索引的结构应该是尽可能少的执行磁盘IO操作，因为执行磁盘IO操作非常的耗时。因此，平衡二叉树并不适合作为索引结构。

### B-Tree 适合作为索引
> 平衡二叉树没能充分利用磁盘预读功能，而B树是为了充分利用磁盘预读功能来而创建的一种数据结构，也就是说B树就是为了作为索引才被发明出来的的。

B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。
也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的
数据进行查找。

B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中。因此，虽然B树查询查询的次数不比平衡二叉树的次数少，但是相比起磁盘IO速度，内存中比较的耗时就可以忽略不计了。因此，B树更适合作为索引。

### 比B树更适合作为索引的结构——B+树
> 比B树更适合作为索引的结构是B+树。MySQL中也是使用B+树作为索引。它是B树的变种，因此是基于B树来改进的。
为什么B+树会比B树更加优秀呢？

数据库索引采用B+树的主要原因是 `B树` 在 `提高了磁盘IO性能` 的同时并 `没有解决元素遍历` 的 `效率低下` 的问题。

- B树：有序数组+平衡多叉树； 
- B+树：有序数组**链表**+平衡多叉树;

- B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。
做这个优化的目的是为了提高 `区间访问` 的性能。而正是这个特性决定了B+树更适合用来存储外部数据。
- B+树还有一个最大的好处，方便扫库，B树必须用 `中序遍历` 的方法按序扫库，而B+树直接从叶子结点挨个
扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。 

#### B+树的查找过程
![image.png](https://i.loli.net/2020/06/06/uaYAUQWTcz51GmH.png)

如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在 `内存中用二分查找` 确定29在17和35之间，
锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，
发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，
结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，
如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

总结：查找过程主要的性能消耗在磁盘IO，内存中的二分查找操作可以忽略不计。那么整个查找过程的效率就跟B+树的层数成正比了。

#### 关于B+树的层数
我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，
m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项
的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树
要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

**用为什么去搜索，往往会搜索出更加精彩的文章**。




参考文章：
- [数据结构 - 树](https://www.jianshu.com/p/45661b029292)
- [什么是平衡二叉树（AVL）](https://zhuanlan.zhihu.com/p/56066942)

https://www.zhihu.com/question/19856999
https://blog.csdn.net/u010899985/article/details/80981053

https://www.cnblogs.com/aspirant/p/9214485.html
https://blog.ouyangsihai.cn/mian-shi-guan-wen-ni-b-shu-he-b-shu-jiu-ba-zhe-pian-wen-zhang-diu-gei-ta.html