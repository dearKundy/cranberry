> 个人愚见：
> - 对于 MySQL、redis 等数据库都不是强一致的，也不需要考虑强一致的问题，只需要保证最终一致，而且只是主从复制的时候需要考虑最终一致。对于多个主结点，他们本来的数据就是不一样的。
> - zookeeper follower 结点接收到写请求，必须把写请求转发给 master（master结点只有一个） 结点去写，它力求保证所有结点在同一时刻的数据都是一致的（实际上只能做到顺序一致）。所以 zk 涉及到复杂的一致性算法的问题。

### 一致性分类
为了提升系统的可用性、性功能、扩展性，我们可以从两个方面着手：
- 多副本（主从复制）：只能解决读性能问题。
- 数据分片（多 master）：提升系统的写性能。

而对于数据的赋值必然存在数据一致性的问题。

#### 强一致性
- 当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。
- 但是这种实现对性能影响较大，因为这意味着，只要上次的操作没有处理完，就不能让用户读取数据。

#### 顺序一致性
> 所有的进程以相同的顺序看到所有的修改。读操作未必能及时得到此前其他进程对同一数据的写更新。但是每个进程读到的该数据的不同值的顺序是一致的。

#### 弱一致性
> 系统并不保证进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。但会尽可能保证在某个时间级别（比如秒级别）之后，可以让数据达到一致性状态。

#### 最终一致性
> 弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。

参考文章：
- [关于分布式一致性的探究](https://www.hollischuang.com/archives/663)
- [分布式系统一致性分类](https://cloud.tencent.com/developer/article/1015442)

### zk 属于哪种一致性
> zk 属于顺序一致性。Follower通过队列和zxid等顺序标识保证请求的顺序处理，一言不合就会重新同步Leader。

参考文章：
- [Zookeeper是如何保证顺序一致性的](https://www.jianshu.com/p/8e2bfb0cb7a7)


### Paxos、Raft分布式一致性算法应用场景

> 分布式一致性问题，简单的说，就是在一个或多个进程提议了一个值应当是什么后，使系统中所有进程对这个值达成一致意见。

这样的协定问题再分布式系统中很常用，比如：
- 领导者选举（leader electio）：进程对 leader 达成一致。
- 互斥（mutual exclusion）：进程对进入临界区的进程达成一致。
- 原子广播（atomic broadcast）：进程对消息传递（delivery）顺序达成一致。

一般的分布式存储系统经常使用多副本的方式实现容错，每一份数据都保存多个副本，那么如何保证分布式系统中同一数据的多个副本的一致性呢？
- 同步方式：这种方式可以保证副本之间数据的 **强一致性**，写成功返回之后从任意副本读到的数据都是一致的。但是可用性很差，只要任意一个副本写失败，写请求将执行失败。
- 异步方式：
  - 如果采用异步复制的方式，主副本写成功后立即返回，然后在后台异步的更新其它副本。这种方式可用性较好，只要主副本写成功，写请求就执行成功。但是不能保证副本之间数据的强一致性，写成功返回之后从各个副本读取到的数据不保证一致，只有主副本上是最新的数据，其它副本上的数据落后，只提供**最终一致性**。 
  - 如果出现断网导致后台异步复制失败，则主副本和其它副本将长时间不一致，其它副本上的数据一直无法更新，直到网络重新连通。
  - 如果主副本在写请求成功返回之后和更新其它副本之前宕机失效，则会造成成功写入的数据丢失，一致性被破坏。
> 传统的主从同步无法同时保证数据的一致性和可用性，此问题是典型的分布式系统中 **一致性和可用性不可兼得** 的例子。

而Paxos、Raft等分布式一致性算法则可在 **一致性和可用性之间取得很好的平衡**，在保证一定的可用性的同时，能够对外提供强一致性，因此Paxos、Raft等分布式一致性算法被广泛的用于管理副本的一致性，提供高可用性。

一般的分布式系统 CAP 中的 P 都是必选的，如果不选 P 是怎样的？两个副本可以互相通信，既保证C又保证A，但是这样在某个副本出现故障时，都会导致整个系统不可用。

在CAP理论提出十二年之后，其作者又出来辟谣（其实就是 BASE 理论）。“三选二”的公式一直存在着误导性，它会过分简单化各性质之间的相互关系：
- 这三种性质都可以在程度上衡量，并不是非黑即白的有或无。可用性显然是在0%到100%之间连续变化的，一致性分很多级别，连分区也可以细分为不同含义，如系统内的不同部分对于是否存在分区可以有不一样的认知。
- 所以一致性和可用性并不是水火不容，非此即彼的。Paxos、Raft等分布式一致性算法就是在一致性和可用性之间做到了很好的平衡的见证。

参考文章：
- [https://zhuanlan.zhihu.com/p/31727291](https://zhuanlan.zhihu.com/p/31727291)


### paxos 算法
#### paxos 算法背景
> 自Paxos问世以来就持续垄断了分布式一致性算法，Paxos这个名词几乎等同于分布式一致性。Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如Chubby、Megastore以及Spanner等。开源的ZooKeeper，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。

然而，Paxos的最大特点就是难，不仅难以理解，更难以实现。

#### Paxos算法流程
> Paxos算法解决的问题正是分布式一致性问题，即一个分布式系统中的各个进程如何就某个值（决议）达成一致。

Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障。

Paxos将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):

- Proposer: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。
- Acceptor：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。
- Learner：不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）。

Paxos算法通过一个决议分为两个阶段（Learn阶段之前决议已经形成）：
- 第一阶段：Prepare阶段。Proposer向Acceptors发出Prepare请求，Acceptors针对收到的Prepare请求进行Promise承诺。
- 第二阶段：Accept阶段。Proposer收到多数Acceptors承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理。
- 第三阶段：Learn阶段。Proposer在收到多数Acceptors的Accept之后，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners。

### ZAB 协议
> 在分布式系统中，对于数据一致性的问题，Paxos 算法是比较主流的解决思路，像谷歌的 Chubby 就是基于 Paxos 算法的思想实现的。但在目前使用比较广泛的开源分布式锁服务 ZooKeeper 中，并没有使用采用 Paxos 算法，而是基于 ZAB 协议实现的。

ZAB（ZooKeeper Atomic Broadcast）协议是专门为 ZooKeeper 设计的一种支持崩溃恢复的原子广播协议，与 Paxos 算法最大的区别就是增加了崩溃恢复的功能。

从整体上来看，ZAB 协议包括两种模式：崩溃恢复模式和消息广播模式。
- 广播（boardcast）：Zab 协议中，所有的写请求都由 leader 来处理。正常工作状态下，leader 接收请求并通过广播协议来处理。

- 恢复（recovery）：当服务初次启动，或者 leader 节点挂了，系统就会进入恢复模式，直到选出了有合法数量 follower 的新 leader，然后新 leader  负责将整个系统同步到最新状态。

#### 广播
> 广播的过程实际上是一个简化的二阶段提交过程。

1. Leader 接收到消息请求后，将消息赋予一个全局唯一的 64 位自增 id，叫做：zxid，通过 zxid 的大小比较即可实现因果有序这一特性。
2. Leader 通过 **先进先出队列**（通过 TCP 协议来实现，以此实现了全局有序这一特性）将带有 zxid 的消息作为一个 **提案（proposal）** 分发给所有 follower。
3. 当 follower 接收到 proposal，先将 proposal 写到硬盘，写硬盘成功后再向 leader 回一个 ACK。
4. 当 leader 接收到 **合法数量** 的 ACKs 后，leader 就向 **所有** follower 发送 **COMMIT** 命令，**同时会在本地执行该消息。**
5. 当 follower 收到消息的 COMMIT 命令时，就会**执行该消息**。

> 相比于完整的二阶段提交，Zab 协议最大的区别就是不能终止事务，follower 要么回 ACK 给 leader，要么抛弃 leader，在某一时刻，leader 的状态与 follower 的状态很可能不一致，因此它不能处理 leader 挂掉的情况，所以 Zab 协议引入了恢复模式来处理这一问题。从另一角度看，正因为 Zab 的广播过程不需要终止事务，也就是说不需要所有 follower 都返回 ACK 才能进行 COMMIT，而是只需要合法数量（2f+1 台服务器中的 f+1 台） 的follower，也提升了整体的性能。


#### 恢复
> 由于之前讲的 Zab 协议的广播部分不能处理 leader 挂掉的情况，Zab 协议引入了恢复模式来处理这一问题。为了使 leader 挂了后系统能正常工作，需要解决以下两个问题：

- 已经被处理的消息不能丢。
- 被丢弃的消息不能再次出现。

参考文章
- [Zab：Zookeeper 中的分布式一致性协议介绍](https://www.jianshu.com/p/fb527a64deee)

