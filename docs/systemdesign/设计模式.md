**软件开发一个不变的真理**
- CHANGE

## 设计原则
- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起（把会变的部分取出并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分），所有的设计模式都提供了一套方法让“系统中的某部分改变不会影响其他部分”。
- 针对接口编程，而不是针对实现编程（以前的做法是：行为来自超类的具体实现，或是继承某个接口并由子类自行实现而来。这两种做法都是依赖于“实现”）
- 多用组合，少用继承。
- 为了交互对象之间的松耦合设计而努力。
- 类应该对扩展开放，对修改关闭（我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为）。
- 要依赖抽象，不要依赖具体类。
- 最少知道原则
- 一个类应该只有一个引起变化的原因

## 常见设计模式
`策略模式`：定义了**算法族**，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立与使用算法的客户。

`观察者模式`：定义了对象之间的 **一对多** 依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

`装饰者模式`：动态地将责任附加到对象上，若要**扩展功能**，装饰者提供了比继承更有弹性的替代方案。
- 扩展A类的功能，却不用修改A类的代码

`工厂模式`：通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。
- `简单工厂模式`：工厂是new出来的，产品是抽象的
- `抽象工厂模式`：工厂也是抽象的

`单例模式`：确保一个类只有一个实例，并提供一个全局访问点

`命令模式`：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

`适配器模式`：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
- 实现一个适配器所需要进行的工作与目标接口的大小成正比
- 双向适配器：支持两边的接口（新旧接口），适配器实现新旧两个接口即可

`外观者模式`：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
- 其实就是将多个复杂的方法封装成一个方法，直接调用
- 提供简化的接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用

`模板方法模式`：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法是的子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
- 模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。

`迭代器模式`：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
- 类的每个责任都有改变的潜在区域，意味着超过一个改变的区域
- 尽量让每个类保持单一责任

`组合模式`：允许你将对象组合成树形结构来表现“整体/部分”层次。组合能让客户以一致的方式处理个别对象以及对象组合。
- 马士兵老师讲责任链模式的时候的例子中的如何将一条责任链加到另一条责任链

`状态模式`：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
- 这个模式将状态封装成独立的类，并将动作委托到代表当前状态的对象，行为会随着内部状态而改变

`代理模式`：为另一个对象提供一个替身或占位符以控制对这个对象的访问。

`复合模式`：复合模式结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。
- 例如：MVC模式

## 内聚
- 内聚这个属于用来度量一个类或模板紧密地达到单一目的或责任。
- 当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。

## 策略模式 vs 命令模式
- 策略模式是通过不同的算法做同一件事情
- 命令模式则是通过不同的命令做不同的事情

## 策略模式 vs 状态模式
- 策略模式是围绕可以互换的算法来创建成功业务。然后，状态走的是更崇高的路，它通过改变对象内部的状态来帮助对象控制自己的行为。
- 以状态模式而言，我们将一群行为封装在状态对象中，context的行为随时可委托到那些状态对象中的一个。随着时间的流逝，当前状态在状态对象集合中游走改变，以反映出context内部的状态，因此，context的行为也会跟着改变。但是context的客户对于状态对象了解不多，甚至根本是浑然不觉
- 而已策略模式而言，客户通常主动指定context所要组合的策略对象是哪一个。
- 一般来说，我们把策略模式想成是除了继承之外的一种弹性替代方案。如果你使用继承定义了一个类的行为，你将被这个行为困住，甚至要修改它都很难。有了策略模式，你可以通过组合不同的对象来改变行为。
- 我们把状态模式想成是不用在context中放置许多条件判断的替代方案。通过将行为包装进状态对象中，你可以通过在context内简单地改变状态对象来改变context的行为。

## 装饰器模式 vs 适配器模式
- 装饰器模式：将对象包装起来，赋予它们新的职责（在原来对象的基础上扩展功能，包装完之后还是属于原来的接口）
- 适配器模式：包装某些对象，让它们的接口看起来不像自己而像是别的东西（将类的接口转换成想要的接口）

## 适配器模式 vs 外观者模式
- 它们两者的差异不在于“包装”了几个类，而是在于它们的意图。适配器模式的意图是，“改变”接口符合客户的期望；而外观者模式的意图是，提供子系统的一个简化接口。

## 远程方法调用
假如我们想要设计一个系统，能够调用本地对象，然后将每个请求转发到远程对象上进行。要如何设计？我们需要一些辅助对象，帮我们真正进行沟通。
![b8b0022eb207bc7165dbfe5013730b62.jpeg](evernotecid://F9646F1F-7FC1-4C73-A1CC-2EA46B3D1DB1/appyinxiangcom/19914419/ENResource/p271)

**方法调用如何发生的**
1. 客户对象调用客户辅助对象的doBigThing()方法。
2. 客户辅助对象打包调用信息（变量、方法名称等），然后通过网络（socket）将它运给服务辅助对象。
3. 服务辅助对象把来自客户辅助对象的信息解包，找出被调用的方法（以及在哪个对象内），然后调用真正的服务对象上的真正方法。
4. 服务对象的方法被调用，将结果返回给服务辅助对象。
5. 服务辅助对象把调用的返回信息打包，然后通过网络（socket）运回给客户辅助对象。
6. 客户辅助对象把返回值解包，返回给客户对象。对于客户来说，这是完全透明的。

## Java RMI
RMI提供了客户辅助对象和服务辅助对象，为客户辅助对象创建和服务对象相同的方法。**RMI的好处在于你不必亲自写任何网络或I/O代码**。客户程序调用远程方法（即真正的服务所在）就和在运行在客户自己的本地JVM上对对象进行正常方法调用一样。

因为RMI通过网络发送方法调用，我们知道网络和I/O是有风险的，容易失败，所以随时都可能抛出异常。

RMI将客户辅助对象称为stub（桩），服务器辅助对象称为skeleton（骨架）。

## 定义设计模式
模式：是在某情景下，针对某问题的某种解决方案。




