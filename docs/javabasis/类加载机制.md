> 这篇文章主要是源于对周志明老师的《深入理解Java虚拟机》类加载机制章节的读书笔记。

这里讨论的是类加载机制，对同一个类加载器来说，类只会被加载一次，不涉及到类的具体使用（例如对象实例化），对象的实例化是可以进行 N 次的。

### 虚拟机类加载机制
代码编译的结果从本地机器码转变为字节码（.java文件 -> .class文件）
.class文件是二进制文件，那为啥再idea target中打开可以看到原始代码（那是idea反编译的结果）。

⚠️**敲黑板，划重点**⚠️
虚拟机把**描述类的数据**从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的**Java类型**，这就是虚拟机的类加载机制。

整过程 .java经过编译成 .class文件，.class文件通过类加载过程，加载到内存中转换成Java类型，程序就可以使用该类了。

> .Class 文件都需要加载到虚拟机中之后才能被运行和使用。

那么问题来了
1. 类什么时候会被加载？（肯定不是虚拟机启动就一口气全部加载）
2. 类的加载过程是怎样的？

#### 7.2 类加载的时机
类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期如下图所示（七个阶段）：
![WechatIMG537.jpeg](https://i.loli.net/2019/08/31/CfQtxw9OJnXmBZF.jpg)

> 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按部就班地 **开始**（他们只是按顺序开始，但是并不保证前一个阶段完成之后，后一个阶段才能开始。可以理解为操作系统中的 ”并行“），而 **解析阶段** 则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（多态）。

> `Self-summary`：类生命的终点就是被 `卸载`，而类又必须 `初始化` 之后才能被 `使用`。所以最后的3步必须严格按顺序`开始、结束`。我们现在来看特殊一点的前五步的执行顺序。正常情况下这5步按顺序**开始**，但是考虑到 Java 的 `多态` 特性，`解析` 不一定发生在 `初始化` 之前。

什么情况下需要开始类加载过程的第一个阶段：加载。
虚拟机规范中并没有进行强制约束，由虚拟机实现自由把握。但是虚拟机规范严格规定了**有且只有**四种情况必须立即对类进行 `初始化`（既然要进行初始化，加载、验证、准备自然也需要在此之前开始）：
1. 遇到 new、getstatic、putstatic或invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这个4条指令的最常见的Java代码场景是：
    - 使用 new 关键字实例化对象的时候
    - 读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候
    - 调用一个类的静态方法的时候。
2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。

上面四种场景称为对一个类进行主动引用，除此之外所有引用类的方式，都不会触发初始化，称为被动引用。下面举三个例子来说明被动引用：
1. 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。（注意：但是访问子类的任何静态字段，都会触发父类的初始化）
2. 通过数组定义来引用类，不会触发此类的初始化。
3. 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

```java
/**
 * 1. 被 final 修饰、已在编译期把结果放入常量池的静态字段，
 * 可以理解为常量不属于任何一个类，所以访问这类型的字段不会导致类的任何初始化操作。
 * 2. Java 很好的体现了懒加载，当我们只是使用到静态变量时，只会触发静态初始化块，而不会触发实例初始化块 。
 * 我们也可以通过 类变量 是所有对象共享的，一个类只有一个的角度去理解。
 * 3. 当我们需要访问实例变量的时候，需要new 对象，这就会执行全部的初始化块了。
 *
 * @author kundy
 * @date 2019/6/16 12:15 AM
 */
public class StaticClass {

    /**
     * 执行类初始化，不会执行初始化实例初始化块
     */
    public static String string = "i am string";


    /**
     * 不会触发类初始化
     */
    public static final String string1 = "i am string";

    /**
     * 想要访问改变变，必须new StaticClass()，最终导致类初始化块与实例初始化块都执行
     */
    public String string2 = "i am string";

    static {
        System.out.println("StaticClass 静态变量初始化。。。");
    }

    {
        System.out.println("StaticClass 成员变量初始化。。。");
    }

    /**
     * 调用静态方法，仅会触发静态初始化块，不会触发实例初始化块
     */
    public static void sayHi() {
        System.out.println("StaticClass sayHi()");
    }

}

```

#### 7.3 类加载的过程

##### 7.3.1 加载
在加载阶段，虚拟机需要完成以下三件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为 MetaSpace 的运行时数据结构。
3. 在Java堆中生成一个代表这个类的`java.lang.Class` 对象，作为 MetaSpace 这些数据的访问入口。

“通过一个类的全限定名来获取定义此类的二进制字节流”，并没有指明二进制字节流要从一个Class文件中获取，我们还可以以一下几种方式获取：
- 从ZIP包中读取，着很常见，最终成为日后 JAR、EAR、WAR格式的基础。
- 从网络中获取，这种场景最典型的应用就是 Applet。
- 运行时生成，这种场景使用最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 PRoxyGenerateProxyClass 来为特定接口生成 `*$Proxy` 的代理类的二进制字节流。
- ...

> 相对于类加载过程的其他阶段，加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发期可控性最强的阶段，因为我们既可以使用系统提供的类加载器来完成，也可以由用户 **自定义的类加载**去完成。

#### 7.3.2 验证
验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。

#### 7.3.3 准备
准备阶段是正式为**类变量**分配内存并设置类变量初始值的阶段，这些内存都将在 metaspace 中进行分配。

这个阶段有两个容易混淆的概念需要强调一下，首先是这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。

其次这里所说的初始值“通常情况”指的是数据的零值，例如 `public static int value=123`
那么变量在value阶段过后的值为0而不是123，把 value 赋值为 123 的动作将在 `初始化` 阶段被执行。

但是有一种例外情况，如果是常量
`public static final int value=123`
那么变量在 valu e阶段过后的值为是 123。

#### 7.3.4 解析
解析阶段是虚拟机将常量池内的符号引用**替换**为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info四种常量类型，那解析阶段中所说的直接引用与符号引用又有什么关联呢？
- `符号引用`：符号引用以一组符合来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
- `直接引用`：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局先关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

#### 7.3.5 初始化
根据程序通过程序制定的主观计划去初始化**类变量**和其他资源。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序制定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。在这里，我们先看一下<clinit>()方法执行过程中可能会影响程序运行行为的一些特点和细节。
- <clinit>() 方法是由编译器自动收集类中的所有**类变量的赋值**动作和**静态语句块**（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问
到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。
- <clinit>() 方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显示的调用父类构造器，虚拟机会保证在子类的<init>()方法执行之前，父类的<init>()方法已经执行完毕。因此在虚拟机中第一个被执行的<init>()方法的类肯定是 java.lang.Object。
- <clinit>() 方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。
- 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
- 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步。

##### 类构造器<clinit> 与对象构造器<init> 的区别



### 7.4 类加载器
虚拟机设计团队把类加载阶段中的"通过一个类的全限定名来获取描述此类的二进制字节流"这个动作放**Java虚拟机外部**去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为"类加载器"。

#### 7.4.1 类与类加载器
类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。比较两个类是否“相等”，只有在这两个类是由一个类加载器加载的前提之下才有意义，否则，即使这两个类是来源于同一个 Class 文件，只要加载它们的类加载器不同，那这两个类就必定不相等。

#### 7.4.2 双亲委派模型
站在Java虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 **C++** 语言实现，是虚拟机本身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader。

从Java开发人员的角度来看，大部分Java程序都会使用到以下三种系统提供的类加载器：
- 启动类加载器：负责加载在`<JAVA_HOME>/lib`目录中类库加载到虚拟机内存中。该加载器无法被Java程序直接引用。
- 扩展类加载器：该类加载器由`sun.misc.Launcher$ExtClassLoader`实现，负责加载`<JAVA_HOME>/lib/ext`目录中的所有类库，开发者可以直接使用该加载器。
- 应用程序类加载器：该类加载器由`sun.misc.Launcher$AppClassLoader`来实现。它负责加载用户类路径`（ClassPath）`上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

##### Self-summary
从虚拟机的角度看，只有两种类加载器：
- `启动类加载器`：用 C++ 语言实现，是虚拟机自身的一部分。
- `其他类加载器`：由 Java 语言实现，独立于虚拟机之外。

从 Java 开发人员的角度看，可以分为三个类型：
- `启动类加载器`：负责加载<JAVA_HOME>\lib目录下的类。
- `扩展类加载器`：负责加载<JAVA_HOME>\lib\ext目录下的类
- `应用程序类加载器`：它负责加载用户类路径（ClassPath）上所指定的类库。

我们的应用程序都是由这 **三种类加载器互相配合** 进行加载的，如果有必要，还可以加入自己定义的类加载器。
![WechatIMG539.png](https://i.loli.net/2019/08/31/k4iLdtZME8IUQcG.png)

上图展示的类加载器之间的这种层次关系，就称为类加载器的 **双亲委派模型**（Parent Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系实现，而是都使用组合关系来复用父加载器的代码。

类加载器的双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者们推荐给开发者们的一种类加载器
实现方式。

双亲委派模型的工作过程是：如果一个类加载器接收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父亲加载器去完成，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。（自定义加载器属于应用程序加载器，它的父加载器是扩展类加载器，而不是应用程序加载器）。

使用双亲委派模式来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此 Object 类在程序的各种类加载环境中都是同一个类。你可以尝试去写一个与 rt.jar 类库中已有类重名的Java类，将会发现可以正常编译，但永远无法被加载运行。

双亲委派模型对于保证 Java 程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass() 方法之中，它首先检查是否已经被加载过，若没有加载则调用父加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，则在抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。

#### 如何实现热部署
**为什么需要热部署？**

如果没有热部署，当我们修改一个类的时候必须要重启虚拟机才可以生效。因为一个类加载器只能加载一个同名类，在Java默认的类加载器层面作了判断，如果已经有了该类，则不再重复加载。

**如何实现？**

使用自定义的类加载器，加载一个类，当需要进行替换类的时候，我们就丢弃之前的类加载器和类，使用新的类加载器去加载新的Class 文件，然后运行新对象的方法。


- 由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。
- 当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载（从而静态变量设值一次，到处使用）。