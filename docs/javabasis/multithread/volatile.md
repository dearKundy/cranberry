## volatile

- `为什么需要`：
    - 工作内存与主内存数据不一致。
    - 为了充分利用处理器，指令顺序会被打乱。
- `作用`：
    - `可见性`：当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。（`synchronized` 与 `final` 也能实现可见性）
    - `禁止指令重排序`：
- `实现原理` ：
    - 假定T表示一个线程，V和W分别表示两个volatile 型变量，那么在进行 read、load、use、assign、store 和 write 操作时需要满足如下的规则：
        - 在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能见其他线程对变量V所做的修改后的值。
        - 在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改
        - volatile 修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。
     - `总结`：取值必须从主内存中取，修改完之后必须刷回主内存，而取值、刷值必然是要加锁的（内存屏障）。
- `happens-before`：如果一个操作执⾏的结果需要对另一个操作可⻅，那么这两个操作之间必须存在 `happens-before` 关系。


synchronized既保证原子性也保证可见性
- 在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存->在主内存中拷贝最新变量的副本到工作内存->执行完代码->将更改后的共享变量的值刷新到主内存中->释放互斥锁
- synchronized的范围越小越好

volatile只保证可见性（对于共享变量，线程A改了共享变量的值，线程B可见）
- volatile实现内存可见性是通过store和load指令完成的；也就是对volatile变量执行写操作时，会在写操作后加入一条store指令，即强迫线程将最新的值刷新到主内存中；而在读操作时，
会加入一条load指令，即强迫从主内存中读入变量的值。但volatile不保证volatile变量的原子性
 