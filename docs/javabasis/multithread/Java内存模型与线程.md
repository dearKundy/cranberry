
> 这篇文章主要是源于对周志明老师的《深入理解Java虚拟机》Java内存模型与线程章节的读书笔记。

## 12.1 概述
多任务处理在现代计算机操作系统中几乎已是一项必备的功能了。在许多情况下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通讯子系统速度的差距太大，大部分时间都花在了磁盘 I/O 、网络通讯和数据库访问上。如果不希望处理器在大部分时间里都处于等待其他资源的状态，就必须使用一些手段去把处理器的运算能力“压榨”出来，否则就会造成很大的“浪费”，而让计算机同时处理几项任务则是最容易想到、也被证明是非常有效的“压榨”手段。

衡量一个服务器性能的高低好坏，每秒事务处理数（Transaction Per Second，TPS）是最重要的指标之一，它代表着一秒内服务器平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。

## 12.2 硬件的效率与一致性
在正式讲解Java虚拟机并发相关的知识之前，我们先花费一点时间去了解一下物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对虚拟机的实现也有相当大的参考意义。

所有的运算任务都不可能只靠处理器“计算”就能完成，至少与内存的交互，如读取运算数据、存储运算结果等，就是很难消除的（不能仅仅靠寄存器来解决）。由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓存；将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步会内存之中，这样处理器就无须等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：**缓存一致性**（Cache Coherence）。在许多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，当多个处理器的运算任务都涉及同一主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI MESI MOSI Synapse Firefly及Dragon Protocol，等等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的。

![WechatIMG531.jpeg](https://i.loli.net/2019/08/31/olkEgIQGZb3s4Om.jpg)

除此之外，为了使得处理器内存的运算单元尽可能被 `充分利用` ，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重排，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务以来另一个计算任务的中间结果，那么其顺序并不能依靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的 `指令重排序`（Instruction Reorder）优化。

## 12.3 Java内存模型
Java 虚拟机规范试图定义一种 Java 内存模型来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能到达一致的并发效果。在此之前，主流程序语言(如C/C++等)直接使用物理硬件（或者说操作系统的内存模型），因此，会由于不同平台上内存模型的差异，导致程序在一套平台上并发完全正常，而在另一套平台上并发访问却经常出错，因此经常需要针对不同的平台来编写程序。

### 12.3.1 主内存与工作内存
Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程中所说的变量略有区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不存在竞争问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权利。

Java内 存模型规定了 `所有的变量都存储在主内存` 中（此处的主内存与物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。 `每条线程还有自己的工作内存` （可与前面所讲的处理器高速缓存类比），线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读写、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量的值均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示。

![WechatIMG532.jpeg](https://i.loli.net/2019/08/31/zOxcukEopi9W5Ss.jpg)

这里所讲的主内存、工作内存与之前所讲的Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分。如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中对象的实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存有限存储与寄存器和高速缓存中。

### 12.3.2 内存间交互操作
关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了以下八种操作来完成：
- `lock`（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- `unlock`（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- `read`（读取）：作用于主内存的变量，它把一个变量的值从主内存**传输**到线程的工作内存中，以便随后的load动作使用。
- `load`（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- `use`（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- `assign`（赋值）：作用于工作内存的变量，它把一个从执行引擎接收大的值赋值给工作内存变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- `store`（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
- `write`（写入）:作用于主内存的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中。

如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行 `read` 和 `load` 操作，如果要把变量从工作内存同步会主内存，就要按顺序地执行 `store` 和 `write` 操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证必须是连续执行。也就是说 `read` 和 `load` 之间、`store` 与 `write` 之间是可插入其他指令的，如对内存中的变量 a、b 进行访问时，一种可能出现的顺序是read a、read b、load b、load a。除此之外，Java内存模型该规定了在执行上述八种基本操作时必须满足如下规则：
- 不允许 `read` 和 `load` 、`store` 和`write` 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作：也不允许unlock一个被其他线程锁定住的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）。

### 12.3.3 对于volatile型变量的特殊规则
关键字 `volatile` 可以说是 Java 虚拟机提供的最轻量级的同步机制，但是它并不容易理解。

Java 内存模型对 `volatile` 专门定义了一些特殊的访问规则。当一个变量被定义成volatile之后，它将具备两种特性，第一是保证次变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，变量值在线程间传递均需要通过主内存来完成，如：线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成之后再从主内存进行读取操作，新变量的值才会对线程B可见。

但是volatile只能保证可见性，不能保证原子性。具体看下面程序例子
```java
public class VolatileTest {

    public static volatile int race = 0;
    private static CountDownLatch latch = new CountDownLatch(20);

    public static void increase() {
        race++;
    }

    private static final int THREADS_COUNT = 20;

    public static void main(String[] args) throws Exception {
        Thread[] threads = new Thread[THREADS_COUNT];
        for (int i = 0; i < THREADS_COUNT; i++) {
            new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    increase();
                }
            }).start();
            latch.countDown();
        }
        latch.await();
        System.out.println(race);
    }
}
```
这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。但是实际的运行结果输出每次都不一样，都是一个小于200000的数字，这是为什么呢？

虽然线程对变量的修改会刷回主内存，保证每个线程对变量的修改其他线程都是可见。但是在并发的场景下，完全是有可能多个线程同时去读了主内存同一状态的数据。即会出现上述的问题，即不能保证原子性。

由于volatile变量只能保证可见性，在不符合一下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。
- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
- 变量不需要与其他的状态变量共同参与不变约束。

使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因此在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”。

最后，我们在回头来看看Java内存模型中对volatile变量定义的特殊规则。假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下的规则：
- 在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能见其他线程对变量V所做的修改后的值。
- 在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改
- volatile 修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。

### 12.3.5 原子性、可见性与有序性
Java内存模型是围绕着并发过程中如何处理原子性、可见性和有序性这三个特征来建立的，我们逐个来看一下哪些操作实现了这三个特征。
- `原子性`
    - 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，**我们大致可以基本数据类型的访问读写是具备原子性的**
    - 如果应用场景需要一个**更大范围**的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块-synchronized关键字，因此synchronized块之间的操作也具备原子性。
- `可见性`
    - 可见性就是指当前一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，无论是普通变量还是volatile变量都是如此才，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量不能保证这一点。
    - 除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，那么在其他线程中就能看见final字段的值。

- `有序性`
    - Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。
    - Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条获得，这个规则决定了持有同一个锁的两个同步块只能串行地进入。


### 12.3.6 先行发生原则
如果Java内存模型中所有有序性都只靠volatile和synchronized来完成，那么有一些操作将会变得很啰嗦，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”（happens-before）的原则。这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的主要依据，依赖这个原则，我们可以通过几条规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题。

下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。
- `程序次序规则`：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
- `管程锁定规则`：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
- `volatile变量规则`：对一个 `volatile` 变量的写操作先行发生于后面对这个变量的读操作，这里的”后面“同样是指时间上的先后顺序。
- `线程启动规则`：Thread对象的start()方法先行发生于此线程的每一个动作。
- `线程终止规则`：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
- `线程中断规则`：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
- `对象终结规则`：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
- `传递性`：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

Java语言无须任何同步手段保障就能成立的先行发生规则就只有上面这些了。

在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在`happens-before`关系


## ThreadLocal

ThreadLocal与线程同步机制不同，线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每个线程创建一个单独的变量副本，故每个线程都可以独立改变自己所拥有的变量副本，而不会影响其他线程所对应的副本。可以说ThreadLocal为多线程环境下变量问题提供了另外一种解决思路。

ThreadLocal内部有一个静态内部类ThreadLocalMap，该内部类才是实现线程隔离机制的关键，get()、set()、remove()都是基于该内部类操作。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。

对于ThreadLocal需要注意的有两点：
1. ThreadLocal实例本身是不存储值，它只是提供了一个在当前线程中找到副本值的key

2. 是ThreadLocal包含在Thread中，而不是Thread包含在ThreadLocal中

### ThreadLocal 源码分析
ThreadLocal 中的 set 方法。
```java
    public void set(T value) {
        // 获取当前正在set的线程
        Thread t = Thread.currentThread();
        // 获取当前线程的threadLocals成员变量
        ThreadLocalMap map = getMap(t);
        if (map != null)
            // 把当前的ThreadLocal对象作为key值存到当前线程的threadLocals成员变量中
            map.set(this, value);
        else
            // 初始化当前线程的threadLocals成员变量，并赋值。
            createMap(t, value);
    }
```

ThreadLocal 中的 get 方法。
```java
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            // 使用当前ThreadLocal对象查找相应的值
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
```
总结：
- ThreadLocal 的 set 方法是把值设到当前线程的 threadLocals 成员变量中。key 是 ThreadLocal 本身。
- 一个线程可以存储多个 ThreadLocal 的值，key 为各个 ThreadLocal 本身。
- threadLocals 是一个 ThreadLocalMap 类型，可以理解为就是一个 Map。
