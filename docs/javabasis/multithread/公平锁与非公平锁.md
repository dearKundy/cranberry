> 公平锁就是保障了多线程下各线程获取锁的顺序，先到的线程优先获取锁，而非公平锁则无法提供这个保障。

## 公平锁
获取锁之前，假如等待队列为空或者自己位于队列头部，可以获得锁，否则排队。

## 非公平锁
进来直接尝试获取锁，失败再排队。

- 若在释放锁的时候总是没有新的线程来打扰，则非公平锁等于公平锁。
- 若释放锁的时候，正好过来一个新的线程竞争锁，且此时位于队列头的线程还没有被唤醒（因为线程上下文切换是需要不少开销的），
此时后来的线程则优先获得锁，成功打破公平，成为非公平锁；
- 其实对于非公平锁，只要线程进入了等待队列，队列里面依然是FIFO的原则，跟公平锁的顺序是一样的。
- 上文说到的线程切换的开销，其实就是非公平锁效率高于公平锁的原因，因为非公平锁 `减少了线程挂起的几率`，
后来的线程有一定几率逃离被挂起的开销。


> synchronized 和 reentrantLock 默认都是非公平锁。

通过 java.util.concurrent.locks.ReentrantLock.ReentrantLock(boolean) 可以指定是否公平锁。

参考文章：
- [一张图读懂非公平锁与公平锁](https://www.jianshu.com/p/f584799f1c77)
