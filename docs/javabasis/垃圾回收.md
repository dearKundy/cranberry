> 这篇文章主要是源于对周志明老师的《深入理解Java虚拟机》垃圾回收章节的读书笔记。

### Linux与进程内存模型
JVM以一个进程的身份运行在Linux系统上。
#### 硬件、系统、进程三个层面的内存之间的概要关系
- `从硬件层面看`：物理内存、swap（位于磁盘）
- `从系统层面看`：内核内存、用户内存
- `从进程层面看`：代码区、数据区、堆区、栈区、未使用区

#### JVM内存模型
JVM内存模型把堆区划分为永久、新生、老年三个区域，由JVM统一管理，好处有两个：
1. 减少系统调用次数
2. 减少内存泄漏

参考文章:
- [https://cloud.tencent.com/developer/article/1057666](https://cloud.tencent.com/developer/article/1057666)

### Java内存区域与内存溢出异常
#### 2.2 运行时数据区域
JVM在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域：
- `程序计数器`：**线程私有的**，当前**线程**所指定的字节码的行号指示器。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。（唯一一个在Java虚拟机规范中没有规定任何OutOfMenory情况的区域）
- `Java虚拟机栈`：**线程私有的**，**它的生命周期与线程相同**。虚拟机栈描述的是**Java方法**的内存模型：每个**方法**被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息、对象引用等。
- `本地方法栈`：**线程私有的**，与虚拟机栈发挥的作用非常相似，只不过本地方法栈是为虚拟机使用到的Native方法服务。
- `Java堆`：**线程共享**，唯一目的就是存放对象实例，垃圾收集器管理的主要区域。如果从内存回收的角度看，由于现在收集器基本都是采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代：在细致一点的有Eden空间、From Survivor 空间、To Survivor 空间等。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。
- `方法区`：**线程共享**，Java虚拟机规范把方法区描述为堆的一个逻辑部分，用于存储以被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。（垃圾收集行为在这个区域较少出现，因为效果不太好）
- `运行时常量池`：是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息时常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在 **编译期产生**，**运行期间也可能将新的常量放入池中**，这种特性被开发人员利用的比较多的便是 String 类的 intern() 方法。
- `直接内存`：主要指的是在NIO中直接分配的堆外内存（内核内存）。

**注意**️：
- Java 8 彻底将永久代 (PermGen/方法区) 移除出了 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Metaspace。
- PermGen 最终被移除，方法区移至 Metaspace，字符串常量移至 Java Heap

Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？
1. 由于 PermGen 内存经常会溢出，引发恼人的 java.lang.OutOfMemoryError: PermGen，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM
2. 移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。

Metaspace（元空间）是哪一块区域？
- JDK 8 开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace，中文名叫元空间。

参考文章：
- [https://www.sczyh30.com/posts/Java/jvm-metaspace/](https://www.sczyh30.com/posts/Java/jvm-metaspace/)

#### 总结：
Java 运行时数据区域：
- `程序计数器`：线程私有，存放下一条指令执行位置。
- `栈`：线程私有，存放临时变量。
- `堆`：线程共享，存放对象。

1.8 以前
- `方法区`：线程共享，堆的一块逻辑区域，存放类信息。（对象类型数据（如对象类型、父亲、实现的接口、方法等）的地址信息）
- `运行时常量池`：线程共享，存放常量，方法区的一个逻辑区域。

1.8 以后
- `metaspace`：线程共享，堆的一部分，存放类信息。
- `运行时常量池`：线程共享，存放常量，堆中划分。


#### 2.3 对象访问
- `句柄池`：Java 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址。在对象被移动（GC时非常普遍的行为）时只改变句柄中的实例数据指针，而reference本身不需要被修改
- `直接指针`：reference中直接存储的就是对象地址。速度更快，节省了一次指针定位的时间开销。

![WechatIMG540.jpeg](https://i.loli.net/2019/08/31/XBOqJU3D1ojsf2T.jpg)
![WechatIMG541.jpeg](https://i.loli.net/2019/08/31/1zOKB8G9XE27ZYH.jpg)


设置堆内存大小，并生成dump文件：`-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError`
设置栈容量：`-Xss160k`
设置方法区大小：`-XX:PermSize=10M -XX:MaxPermSize=10M`(jdk1.7不再适用，方法区（永久代已经被移除）)
设置直接内存大小：`-XX:MaxDirectMemorySize=10M`，如果不指定，则默认与Java堆的最大值（-Xmx）一样

##### Java中的Unsafe类
java不能直接访问操作系统底层，而是通过本地方法来访问。Unsafe类通过native方法提供了硬件级别的原子操作。

### 垃圾收集器与内存分配策略
程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭，每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的，所以在这几个区域内不需要过多考虑回收的问题。而堆中的对象是运行时动态创建的，所以垃圾收集器所关注的主要是堆这部分（包括Metaspace）。

#### 对象已死
进行垃圾回收之前，第一件事就是要确定哪些对象已经“死去”（即不可能再内任何途径使用的对象）。

- `引用计数算法`：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值减1；任何时刻计数器都为0的对象就是不可能再被使用。但是Java语言中没有选用该算法，主要原因是它很难解决对象之间的互相循环引用的问题。
- `根搜索算法`：通过一系列的名为“GC Roots”的对象作为起点，这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。
    - 在根搜索算法中不可达的对象，也并非是“非死不可”，要真正宣告一个对象死亡，至少要经历两次标记过程。

PS:可以添加VM启动参数`-XX:+PrintGCDetails`打印gc日志

### 垃圾收集算法
`标记-清除算法`（mark-sweep）:算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
- 缺点
    - 效率问题：标记和清除过程的效率都不高。
    - 空间问题：标记清楚之后产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。

`复制算法`（copying）：
它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

现在的商业虚拟机都采用这种收集算法来回收**新生代**，研究表明，新生代的对象98%都是朝生夕死，所以不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另一块Survivor空间上，最后清除掉Eden和刚才用过的Survivor的空间。

#### 为什么新生代需要survivor区
减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。

#### 为什么新生代需要有两个survivor区
为了方便新生的与存活的对象可以进行一次性大规模直接复制。
一次 gc 发生后： 
1. Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；
2. 清空 Eden 和 From Survivor ； 
3. 颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From ；
#### 为什么Major GC 比Minor GC慢很多
关于时间的开销
`mark-sweep`（标记-清除）：mark阶段与活对象的数量成正比，sweep阶段与整堆大小成正比 
`mark-compact`（标记-整理）：mark阶段与活对象的数量成正比，compact阶段与活对象的大小成正比 
`copying`：与活对象大小成正比

- 因为新生代朝生夕死，存活对象少，需要复制的对象少，直接使用copying算法，贼快。
- 但是老年代存活对象多，需要复制的对象多，使用copying就失去了性能的优势
- 所以，需要使用mark-sweep避免大量的复制，但是大量的mark-sweep肯定比少量对象的copy要慢的多（当然大量的mark-sweep还是比大量的copy要快的）。

参考文章：
- [https://hllvm-group.iteye.com/group/topic/38223#post-248757](https://hllvm-group.iteye.com/group/topic/38223#post-248757)
- [https://dsxwjhf.iteye.com/blog/2201687](https://dsxwjhf.iteye.com/blog/2201687)

`标记-整理算法`（mark-compact）：
复制收集算法在对象存活率较高时就要执行较多的赋值操作，效率将会变低。所以老年代一般不能直接选用这种算法。

根据老年代的特点，有人提出了另外一种“标记-整理”算法，标记过程仍然与“标记-清楚”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都往一端移动，然后直接清理掉端边界以外的内存。

`分代收集算法`
当前商业虚拟机的垃圾收集都采用“分代收集”算法，这没有什么新的思想。只是根据对象的存活周期的不同将内存划分为几块。一般把Java堆分为新生代与老年代。
> 新生代 -> 复制算法
老年代 -> 标记整理算法

### 垃圾收集器
收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。（没有最好的收集器，只有最适合的收集器）
![WechatIMG542.jpeg](https://i.loli.net/2019/08/31/f4Qy817qibuVWGe.jpg)
如果两个收集器之间存在连线，就说明它们可以搭配使用。

垃圾收集器中并发与并行两个概念的区别：
- 并行：指多条垃圾收集线程并行工作，但此时**用户线程仍然处于等待状态**。
- 并发：指用户线程与垃圾线程同时执行（但不一定是并行的，可能会交替执行）

`Serial收集器`：新生代收集器，单线程收集器，stop the world，单核CPU下会更加高效，适合桌面应用场景。
`ParNew收集器`：并行收集器，Serial收集器的多线程版本，除了使用多个线程同时进行收集之外，其他的跟Serial收集器差不多，包括stop the world（单核CPU中效率会比Serial收集器低）
`Parallel Scavenge`：并行、新生代收集器，其他收集器的关注点是尽可能缩短收集时用户线程的停顿时间，而Parallel Scavenge关注的是吞吐量（CPU用于运行用户代码的时间/运行用户代码的时间+垃圾收集时间），高吞吐量可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。（例如：把新生代的容量调小一点，每一次收集速度肯定会更加快，用户感觉到的停顿时间就短，但是导致垃圾收集更加频繁。相反一次性进行更大容量的回收，每次一收集的速度会慢一点，但是整体的吞吐量就上去了）
`Serial old 收集器`：Serial收集器的老年代版本
`Parallel Old`:Parallel Scavenge的老年代版本(注重吞吐量的场合可以优先考虑Parallel Scavenge+Parallel Old的组合)
`CMS收集器`：（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器。基于 `标记-清除` 算法实现，整个过程分为4个步骤：
1. 初始标记：需要 `stop the world`，仅仅标记一下GC Roots能直接关联到的对象，速度快。
2. 并发标记：进行 GC Roots Tracing 的过程。
3. 重新标记：需要 `stop the world`，修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。
4. 并发清除：

整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作。所以整体来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。

CMS有三个显著的缺点：
1. 对CPU资源非常敏感
2. 无法处理浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留到下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。
3. 基于“标记-清理”算法，产生大量空间碎片

`G1收集器`：

#### 总结
|收集器	|串行、并行or并发	|新生代/老年代|	算法|	目标|	适用场景|
|---|---|---|---|---|---|
|Serial|	串行|	新生代|	复制算法	|响应速度优先|	单CPU环境下的Client模式|
|Serial Old	|串行|	老年代|	标记-整理|	响应速度优先	|单CPU环境下的Client模式、CMS的后备预案
|ParNew	|并行	|新生代|	复制算法|	响应速度优先	|多CPU环境时在Server模式下与CMS配合
|Parallel Scavenge|	并行	|新生代|	复制算法	|吞吐量优先	|在后台运算而不需要太多交互的任务|
|Parallel Old|	并行	|老年代|	标记-整理	|吞吐量优先	|在后台运算而不需要太多交互的任务|
|CMS	|并发	|老年代	|标记-清除|	响应速度优先|	集中在互联网站或B/S系统服务端上的Java应用|
|G1|	并发	|both	|标记-整理+复制算法|	响应速度优先|	面向服务端应用，将来替换CMS|

### 内存分配
下面介绍的是几条最普遍的内存分配规则，具体实现细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。下面的规则是基于Serial/Serial old的基础之上。

#### 对象优先在Eden分配
大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

虚拟机提供了`-XX:PrintGCDetails`这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前内存各区域的分配情况。

一下参数代表什么意义？
`-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8`
限制java堆大小为20MB，且不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。`-XX:SurvivorRatio=8`决定了新生代中Eden区与一个Survivor区的空间比例是8比1。

敲黑板，划重点了
> 新生代GC（Minor GC）：Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
> 来年代GC（Major GC/Full GC）：出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍。

#### 大对象直接进入老年代
所谓大对象就是指，需要大量连续内存空间的Java对象。

虚拟机提供了一个`-XX:PretenureThreshold`参数，令大于这个设置值的对象直接在老年代中分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝。

#### 长期存活的对象将进入老年代
虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数`-XX:MaxTenuringThreshold`来设置。

#### 动态对象年龄判定
虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。无须等到MaxTenuringThreshold中要求的年龄。

#### 空间分配担保
在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；否则，还是进行Full GC。

当大量对象在Minor GC后仍然存活的情况时，就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。但是前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取回之前每一次回收晋升到老年代对象的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

取平均值仍然是一种动态概率手段，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。

总结：
发生Minor GC时（不可避免会有晋升到老年代的对象，或者是Survivor区容纳不下的情况），虚拟机会根据经验值来判断是老年代的剩余空间是否足够容纳晋升的对象。如果判断为不够，直接Full GC。否则看
是否允许担保失败（因为根据经验值来判断是一个概率值，依然还是会出现晋升对象突增的情况，这时候就会担保失败，依然执行Full GC），如果允许，就只进行Minor GC，否则Full GC。一般情况下都是打开允许担保的开关，避免过于频繁的GC。

#### Linux使用jstat命令查看JVM的GC情况
jstat命令格式：
`jstat [Options] vmid [interval] [count]`
- `Options`，选项
    - `-class`：监视类装载、卸载数量、总空间及类装载所耗费的时间。
    - `-gc`：监视各个区的容量、已用空间、GC时间合计等信息
    - `-gcutil`：监视内容与-cg基本相同，但主要关注已使用空间占总空间的百分比
- `vmid`，VM的进程号，即当前运行的java进程号
- `interval`，间隔时间，单位为秒或者毫秒
- `count`，打印次数，如果缺省则打印无数次

结果说明：
- S0C：年轻代中第一个survivor（幸存区）的容量 (字节) 
- S1C：年轻代中第二个survivor（幸存区）的容量 (字节) 
- S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (字节) 
- S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (字节) 
- EC：年轻代中Eden（伊甸园）的容量 (字节) 
- EU：年轻代中Eden（伊甸园）目前已使用空间 (字节) 
- OC：Old代的容量 (字节) 
- OU：Old代目前已使用空间 (字节) 
- PC：Perm(持久代)的容量 (字节) 
- PU：Perm(持久代)目前已使用空间 (字节) 
- YGC：从应用程序启动到采样时年轻代中gc次数 
- YGCT：从应用程序启动到采样时年轻代中gc所用时间(s) 
- FGC：从应用程序启动到采样时old代(全gc)gc次数 
- FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s) 
- GCT：从应用程序启动到采样时gc用的总时间(s) 
- NGCMN：年轻代(young)中初始化(最小)的大小 (字节) 
- NGCMX：年轻代(young)的最大容量 (字节) 
- NGC：年轻代(young)中当前的容量 (字节) 
- OGCMN：old代中初始化(最小)的大小 (字节) 
- OGCMX：old代的最大容量 (字节) 
- OGC：old代当前新生成的容量 (字节) 
- PGCMN：perm代中初始化(最小)的大小 (字节) 
- PGCMX：perm代的最大容量 (字节)   
- PGC：perm代当前新生成的容量 (字节) 
- S0：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比 
- S1：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比 
- E：年轻代中Eden（伊甸园）已使用的占当前容量百分比 
- O：old代已使用的占当前容量百分比 
- P：perm代已使用的占当前容量百分比 
- S0CMX：年轻代中第一个survivor（幸存区）的最大容量 (字节) 
- S1CMX ：年轻代中第二个survivor（幸存区）的最大容量 (字节) 
- ECMX：年轻代中Eden（伊甸园）的最大容量 (字节) 
- DSS：当前需要survivor（幸存区）的容量 (字节)（Eden区已满） 
- TT： 持有次数限制 
- MTT ： 最大持有次数限制 


### 父进程，子进程，线程在操作系统中与JVM中如何呼应
父进程fork出一个子进程。
JVM以一个父进程的身份在Linux上运行，多个Java程序就是JVM的子进程。

### JVM监控工具
#### jps：虚拟机进程状况工具
jps 命令格式
`jps [options] [hostid]`
![WechatIMG543.jpeg](https://i.loli.net/2019/08/31/7DkArEL8ic6pCes.jpg)

#### jstat：虚拟机统计信息监控工具
> 可以显示虚拟机进程中的类装载、内存、垃圾手机、JIT 编译等运行数据。

#### jinfo
> 实时查看和调整虚拟机的各项参数。


#### 使用jmap生存堆转储快照
`jmap -dump:format=b,file=/Users/kun/Desktop/TestThree.hprof 70264`

#### jhat:虚拟机对转储快照分析工具
用来分析jmap生成的堆转储快照，一般不会使用，因为基本上不会直接在服务器上分析dump文件。

#### jstack
jstack 命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。