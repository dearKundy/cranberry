- 在where后面的索引字段上做数学运算或函数运算。
    - 假如本来是按照值a,b,c建立的索引，现在经过函数运算后可能会变成ac、bd、cd，这索引不就呼应不上了嘛。
    
- 对索引字段隐式转型，假设表 A 中的 code 字段为字符串型。执行如下SQL `SELECT * FROM A WHERE code = 58219347`，该SQL中存在隐式转型（VARCHAR -> int），索引失效。
- 索引列使用`IS NOT NULL`，`!=`，`<>` 作为过滤条件，索引失效。
- 单独使用联合索引的非第一个字段作为过滤字段
- like以通配符开头('%abc...')，mysql索引失效会变成全表扫描的操作。
    - 罪魁祸首是%，不是`LIKE`，`LIKE` 条件是 `type = range` 级别
    - `%xxx%`：全表扫描
    - `%xxx`：全表扫描
    - `xxx%`：range
- 存在表 htt_app_user ，userPwd 为索引字段
    - `EXPLAIN SELECT userPwd FROM htt_app_user`：type 为 index，即通过索引树进行全表扫描，不需要回表，索引树上就有userPwd字段。
    - `EXPLAIN SELECT firstShare,userPwd FROM htt_app_user`，type 为 ALL，直接全表扫描，即遍历原本的数据文件，虽然大家都是B+树，但是原本的数据文件会比索引文件要大，因为原本的数据文件包含了整行记录。所以ALL 效率比 INDEX 差点。
    - `EXPLAIN SELECT firstShare,userPwd FROM htt_app_user WHERE userPwd = '123'` type 为 ref，效率不错，因为直接使用索引字段进行过滤，但是firstShare字段不能直接从索引树上找到，需要回表操作，extra为NULL，即没有覆盖索引。
    - `EXPLAIN SELECT userPwd FROM htt_app_user WHERE userPwd = '123'`其他的跟上面SQL结果一样，只是extra 为 Using index，表明使用了覆盖索引，不需要回表，效率高点。
- 排序的时候更加注意需要覆盖索引，否则就算使用了索引列进行排序，还是会导致`FULL TABLE SCAN`，Extra 为 Using filesort ，很致命。