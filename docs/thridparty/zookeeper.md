### 1.1 ZooKeeper概述
ZooKeeper 是一个分布式协调服务的开源框架。主要用来解决分布式集群中应用系统一致性问题，例如怎样避免同时操作同一数据造成脏读的问题。

**ZooKeeper 本质上是一个分布式的小文件存储系统**。提供基于类似于文件系统的 **目录树** 方式的数据存储，并且可以对树中的结点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。诸如：统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。

分布式的小文件存储系统
- `小文件`：说明 ZooKeeper 存储的数据一般比较小。
- `分布式`：说明 ZooKeeper 本身也是一个分布式系统。

### 1.2 ZooKeeper特性
1. `全局数据一致`：每个 server 保存一份相同的数据副本，client 无论连接到哪个 server，展示的数据都是一致的，这是最重要的特征。
2. `可靠性`：如果消息（CRUD）被其中一台服务器接受，那么将被所有的服务器接受。
3. `顺序性`：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。
4. `数据更新原子性`：一次数据更新要么成功（半数以上结点成功），要么失败，不存在中间状态；（假如集群中存在3个ZooKeeper服务，假如其中两个更新成功，另外一个更新失败，那么就可以认为是更新成功，另外一台更新失败的服务会及时同步最新的数据，从而保持一致性）
5. `实时性`：ZooKeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。

### 1.3 ZooKeeper 集群角色
![WechatIMG545.jpeg](https://i.loli.net/2019/08/31/X4H16zCAyx2nYsB.jpg)

`Leader`
- ZooKeeper集群工作的核心
- 事务请求（写操作）的唯一调度和处理者，保证集群事务处理的顺序性；
- 集群内部各个服务器的调度者
- 对于create、setData、delete等有写操作的请求，则需要统一转发给leader处理，leader需要决定编号、执行操作，这个过程称为一个事务。

`Follower`
- 处理客户端非事务（读操作）请求，转发事务请求给leader。
- 参与集群leader选举投票。

此外，针对访问量比较大的ZooKeeper集群，还可新增观察者角色。
`Observer`
- 观察者角色，观察ZooKeeper集群的最新状态变化并将这些状态同步过来，其对于非事务请求可以进行独立处理，对于事务请求，则会转发给Leader服务器进行处理。
- 不会参与任何形式的投票只提供非事务服务，通常用于在不影响集群事务处理能力的前提下提升集群的非事务处理能力。

### 1.4 ZooKeeper集群搭建
ZooKeeper集群搭建指的是ZooKeeper分布式模式安装。通常由`2n+1`台servers组成。这是因为为了保证Leader选举（基于Paxos算法的实现）能获得到多数的支持。

### 2.1 ZooKeeper数据模型
ZooKeeper的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用树形层次结构，ZooKeeper树中的每个结点被称为一个Znode。和文件系统的目录树一样，ZooKeeper树中的每个结点可以拥有子节点。但也有不同之处：
- Znode兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子Znode。用户对Znode具有CRUD等操作。（既是文件也是路径，可以同时属于这两种角色）
- Znode具有原子性操作。
- Znode存储数据大小限制。
- Znode通过路径引用。

### 2.2 结点类型
Znode有两种，分为临时结点和永久结点。结点的类型在创建时即被确定，并且不能改变。
- `临时结点`：该结点的生命周期依赖于创建它们的会话。一旦会话结束（client与server断开连接），临时结点将被自动删除，当然也可以手动删除。**临时结点不允许拥有子节点**（因为如果允许子节点，在一个临时结点下存在三个永久结点，那么断开连接之后，临时结点被删除，那么其子节点（永久结点）也会被删除，这样就互相矛盾了）。
- `永久结点`：该结点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，它们才能被删除。

Znode还有一个序列化的特性，如果创建的时候开启该特性的话，该Znode的名字会自动追加一个不断增加的序列号。序列号对于此节点的父亲点来说是唯一的，这样便会**记录每个子节点创建的先后顺序**

这样便会存在四种类型的Znode结点，分别对应：
- `PERSISTENT`:永久结点
- `EPHEMERAL`:临时结点
- `PERSISTENT_SEQUENTIAL`:永久结点、序列化
- `EPHEMERAL_SEQUENTIAL`:临时结点、序列化

### 2.3 结点属性
每个znode都包含了一系列的属性，通过命令get，可以获得结点的属性。
![WechatIMG546.jpeg](https://i.loli.net/2019/08/31/Y8Q6ojqVB93rFTS.jpg)

- `dataVersion`：数据版本号，每次对结点进行set操作，该值加1（即使设置的是相同的数据），可有效避免了数据更新时出现的先后顺序问题。
- `cversion`：子节点的版本号。当znode的子节点有变化时，该值增加1。
- `aclVersion`：ACL的版本号。
- `cZxid`：Znode创建的事务id。
- `mZxid`：Znode被修改的事务id，即每次对znode的修改都会更新mZxid。
    - 对于zk来说，每次的变化都会产生一个唯一的事务id，zxid（ZooKeeper Transaction Id）。通过zxid，可以确定更新操作的先后顺序。例如，如果zxid1小于zxid2，说明zxid1操作先于zxid2发生，zxid对于整个zk都是唯一的。
- `ctime`：结点创建时的时间戳
- `mtime` ：结点最新一次更新发生时的时间戳
- `ephemeralOwner`：如果该结点为临时结点，该值表示与该节点绑定的session id。如果不是，该值为0.  
    - 在client和server通信之前，首先需要建立连接，该连接称为session。连接建立后，如果发生连接超时、授权失败，或者显式关闭连接，连接便处于CLOSED状态，此时session结束。

### 3.0 启动 zk
路径：zk 是通过压缩包的形式安装的，你懂。
运行 `./zkServer start`

### 3.1 客户端连接
运行`zkCli.sh -server ip`：连接到zk服务，如果不指定ip，则在本地查找zk服务，否则根据ip查找。

### 3.2 shell基本操作
1. 创建结点
    - `create [-s] [-e] path data acl`
        - -s用来指定结点特性（是否是序列化）
        - -e用来指定临时或永久结点
        - 若不指定默认为非序列化永久结点
    - `create /hellozk 123` 
        - 在根目录下创建一个新的结点，值为123
2. 读取结点
与读取相关的命令只有ls和get，ls命令可以列出zk指定结点下的所有子节点，只能查看指定结点下的第一级的所有子节点;get命令可以获取zk指定结点的数据内容和属性信息。
> ls path [watch]
> get path [watch]
> ls2 path [watch]

3. 更新结点
- `set path data [version]`:data就是更新的内容，version表示数据版本（dataVersion）。

4. 删除结点
- `delete path [version]`:若删除结点存在子节点，那么无法删除该结点，必须先删除子节点，再删除父节点。
- `rmr path`：可以递归删除结点。

5. quota
   - `setquota -n|-b val path`:对结点增加限制（超过限制不会报错，只会报警告日志）
       - n:表示子节点的最大个数
       - b：表示数据值的最大长度
       - val：子节点最大个数或数据值的最大长度
       - path：结点路径
   - `listquota path`:列出指定结点的quota
   - `delquota path` 删除quota 

### zkClient 注册监听
> 在 zkClient 中客户端可以通过注册相关的事件来监听来实现对 ZK 服务端事件的订阅。其中 ZK 提供的监听事件接口有以下几种：

|接口类|注册监听方法|解除监听方法|
|---|---|---|
|IZkChildListener|subscribeChildChanges|unsubscribeChildChanges|
|IZkDataListener|subscribeDataChanges|subscribeChildChanges|
|IZkStateListener|subscribeStateChanges|unsubscribeStateChanges|

其中 ZkClient 还提供了一个 unsubscribeAll 方法，来解除所有监听。


### 4.1 ZooKeeper Watcher
ZooKeeper提供了分布式数据发布/订阅功能，一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。

ZooKeeper中，引入了Watcher机制来实现这种分布式的通知功能。ZooKeeper允许客户端向服务端注册一个Watcher监听，当服务端一些事件触发了这个Watcher，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。

触发事件种类很多，如：节点创建，节点删除、节点改变，子节点改变等。

总的来说可以概括Watcher为以下三个过程：客户端向服务端注册Watcher、服务端事件发生触发Watcher、客户端回调Watcher得到触发事件情况。

#### 4.2 Watch机制特点
- `一次性触发`：事件发生触发监听，一个watch event就会被发送到设置监听的客户端，这种效果是一次性的，后续再次发生同样的事情，不会再次触发。
- `事件封装`
    - ZooKeeper使用WatchedEvent对象来封装服务端事件并传送。
    - WatchedEvent包含了每一个事件的三个基本属性：通知状态（KeeperState），事件类型（EventType）和结点路径。
- `event异步发送`：watcher的通知事件从服务端发送到客户端是异步的。
- `先注册在触发`：ZooKeeper中的watch机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。

其中连接状态事件（type=None，path=null）不需要客户端注册，客户端只要有需要直接处理就行了。

### 4.3 Shell客户端设置watcher
`get /wacthtest watch`

### 5.1 ZooKeeper选举机制
ZooKeeper默认的算法是FastLeaderElection，采用投票数大于半数则胜出的逻辑。

- `服务器ID`
    - 比如有三台服务器，编号分别是1，2，3（设置myid文件）
    - 编号越大在选择算法中的权重越大。
- `选举状态`
    - LOOKING:竞选状态
    - FOLLOWING:随从状态，同步leader状态，参与投票
    - OBSERVING:观察状态，同步leader状态，不参与投票
    - LEADING:领导者状态
- `数据ID`
    - 服务器中存放的最新数据version
    - 值越大说明数据约新，在选举算法中数据越新权重越大。
- `逻辑时钟`
    - 也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其他服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。（假如在投票的过程中有一台机器挂了，那么逻辑时钟就会比其他机器少1，自然占的权重也会变低）

### 5.2 全新集群选举
假设目前有5台服务器。每台服务器均没有数据，它们的编号分别是1，2，3，4，5，按编号依次启动，它们的选举过程如下：
- 服务器1启动，给自己投票，然后发投票信息，由于其他机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking。
- 服务器2启动，给自己投票，同时分别与之前启动的服务器1交换结果，由于服务器2的编号大，所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING.
- 服务器3启动，给自己投票，同时分别与之前启动的服务器1，2交换结果，由于服务器3的编号大，所以服务器3胜出，此时投票数大于半数，所以服务器3称为领导，服务器1，2称为小弟。
- 服务器4启动，给自己投票，同时分别与之前启动的服务器1，2，3交换结果，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能称为小弟。
- 服务器5启动，后面的逻辑同服务器4称为小弟。

总结：
1. 每个机器都给自己投票。
2. 投票数过半选举结束。

### 5.3 非全新集群选举
对于运行正常的zk集群，中途有机器down掉，需要重新选举时，选举过程就需要加入数据ID、服务器ID和逻辑时钟。

数据ID：数据新的version就大
服务器ID，就是我们配置的myid中的值，每个机器一个。
逻辑时钟，这个值从0开始递增，每次选举对应一个值。如果在同一次选举中，这个值是一致的。

这样选举的标准就变成：
1. 逻辑时钟小的选举结果被忽略，重新投票
2. 统一逻辑时钟后，数据id大的胜出
3. 数据id相同的情况下，服务器id大的胜出

### ZooKeeper典型应用

#### 7.1 数据发布与订阅（配置中心）
发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK结点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。

应用在启动的时候回主动来获取一次配置，同时，在结点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从而达到获取最新配置信息的目的。比如：
分布式搜索服务中，索引的元信息和服务器集群的结点状态放在ZK的一些指定结点中，共各个客户端订阅使用。

注意：适合数据量很小的场景，这样数据更新可能会比较快。

![WechatIMG547.jpeg](https://i.loli.net/2019/08/31/ur3SygvjbL6Yc28.jpg)

#### 7.2 命名服务（Naming Service）
在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等--这些我们都可以统称他们为名字。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建结点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。

阿里巴巴集团开源的分布式服务框架Dubbo中使用ZK来作为其命名服务，维护全局的服务地址列表。

#### 7.3 分布式锁
分布式所，这个主要得益与ZK保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序。

所谓`保持独占`，就是所有视图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把ZK上的一个znode看做是一把锁，通过create znode的方式来实现。所有客户端都去创建/distribute_lock 结点，最终成功创建的那个客户端也即拥有了这把锁。

`同一瞬间多个线程访在不同的机器（集群）上访问同一个资源，这时候就需要分布式锁`

![WechatIMG548.jpeg](https://i.loli.net/2019/08/31/BMD9u87nXPdVOUG.jpg)


`控制时序`，就是所有试图来获取这个锁的客户端，最终都会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里/distribute_lock已经预先存在，客户端在它下面创建临时有序结点。ZK的父节点（/distribute_lock）维持一份sequence，保证子节点创建的时序性，从而也形成了每个客户端的全局时序。


